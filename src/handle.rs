use super::event::ServerEvent;
use super::map::{InboundMap, Map, OutboundMap};
use crate::event::{ClientEvent, MapEventKind};
use crate::types::ParsingError;
use crate::IpAddress;
use std::sync::mpsc::{self, RecvError};
use std::{fmt, io};

/// Error generated by PCP operations
#[derive(Debug)]
pub enum Error {
    /// Error generated by an I/O operation related to the UDP sockets used for
    /// communication with the PCP server
    Socket(io::Error),

    /// Error generated by one of the channels used for the communication
    /// between the running threads
    Channel(RecvError),

    /// Warning generated when the server responds with a packet with an unknown
    /// format or some invalid values
    Parsing(ParsingError),
}

impl From<io::Error> for Error {
    fn from(err: io::Error) -> Self {
        Self::Socket(err)
    }
}

impl From<RecvError> for Error {
    fn from(err: RecvError) -> Self {
        Self::Channel(err)
    }
}

impl From<ParsingError> for Error {
    fn from(err: ParsingError) -> Self {
        Self::Parsing(err)
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Socket(err) => write!(f, "Socket error: {:?}", err),
            Self::Channel(err) => write!(f, "Inner threads communication error: {:?}", err),
            Self::Parsing(err) => write!(f, "Response parsing error: {:?}", err),
        }
    }
}

/// An handle to a PCP client service
///
/// When a [`Client`][client] is started its [`Handle`] is returned and can be used to
///
/// # Examples
/// `request` mappings and to query its state.
///
/// ## Submitting a request
///
/// Request an inbound mapping to the port 120 TCP:
/// ```
/// // Start the PCP client service
/// let handle = Client::<Ipv4Addr>::start(client, server).unwrap();
///
/// // Allows for any host to connect on the TCP port number 120
/// // (see map module)
/// let map = InboundMap::new(6000, 120).protocol(ProtocolNumber::Tcp);
///
/// // Submit the request to the client, it will live one time
/// handle.request(map, RequestType::Once);
/// ```
/// [client]: crate::client::Client
pub struct Handle<Ip: IpAddress> {
    to_client: mpsc::Sender<ServerEvent<Ip>>,
    from_client: mpsc::Receiver<ClientEvent<Ip>>,
}

impl<Ip: IpAddress> Handle<Ip> {
    pub(crate) fn new(
        to_client: mpsc::Sender<ServerEvent<Ip>>,
        from_client: mpsc::Receiver<ClientEvent<Ip>>,
    ) -> Self {
        Handle {
            to_client,
            from_client,
        }
    }

    /// Renew the mapping with a new lifetime
    ///
    /// This won't have any effect if the provided lifetime is smaller than the current one.
    /// This is better described in the docs for [`shutdown()`]
    pub fn renew(&mut self, id: usize, lifetime: u32) -> bool {
        self.to_client
            .send(ServerEvent::Renew(id, lifetime))
            .is_ok()
    }

    /// Revokes the specified mapping
    ///
    /// This will in turn stop that mapping from being renewed but it won't expire until the end of
    /// it's lifetime. This is better described in the docs for [`shutdown()`]
    pub fn revoke(&mut self, id: usize) -> bool {
        self.to_client.send(ServerEvent::Revoke(id)).is_ok()
    }

    /// Signals the [`Client`](crate::client::Client) to end the execution of the PCP mapping
    /// service
    ///
    /// This won't close all the mappings as once the lifetime of a mapping has beed established
    /// it can't be manually (by a client) reduced as described in the RFC:
    ///
    /// > **15. Mapping Lifetime and Deletition**
    /// >
    /// > [[...]]
    /// >
    /// > It would be unacceptable if an
    /// > attacker could use PCP to intentionally speed up this reassignment of
    /// > the external port in order to deliberately steal traffic intended for
    /// > the current holder, by (i) spoofing PCP requests using the current
    /// > holder's source IP address and mapping nonce to fraudulently delete
    /// > the mapping or shorten its lifetime, and then (ii) subsequently
    /// > claiming the external port for itself.
    /// >
    /// > Therefore, in the simple security model, to protect against this
    /// > attack, PCP MUST NOT allow a PCP request (even a PCP request that
    /// > appears to come from the current holder of the mapping) to cause a
    /// > mapping to expire sooner than it would naturally have expired
    /// > otherwise by virtue of outbound traffic keeping the mapping active.
    /// > A PCP server MUST set the lifetime of a mapping to no less than the
    /// > remaining time before the mapping would expire if no further outbound
    /// > traffic is seen for that mapping.  This means a MAP or PEER request
    /// > with lifetime of 0 will only set the assigned lifetime to 0 (i.e.,
    /// > delete the mapping) if the internal host had not sent a packet using
    /// > that mapping for the idle-timeout time, otherwise the assigned
    /// > lifetime will be the remaining idle-timeout time.
    pub fn shutdown(self) -> bool {
        self.to_client.send(ServerEvent::Shutdown).is_ok()
    }

    /// Request a new mapping to the [`Client`][client]
    ///
    /// After a request is sen't a [`ClientEvent`] of [`NewId`][newidev] may be generated if the
    /// selected mapping id is already in use.
    ///
    /// [client]: crate::client::Client
    /// [newidev]: MapEventKind::NewId
    pub fn request<R: Map<Ip>>(&self, id: usize, map: R, kind: RequestKind) -> bool {
        self.to_client.send(map.into_event(id, kind)).is_ok()
    }
}

impl<Ip: IpAddress> Iterator for Handle<Ip> {
    type Item = ClientEvent<Ip>;

    fn next(&mut self) -> Option<Self::Item> {
        self.from_client.recv().ok()
    }
}

/// The number of times a request has to be submitted
#[derive(Debug, PartialEq)]
pub enum RequestKind {
    /// Repeats for N times after the first submit (thus a value of 0 means only once)
    Repeat(usize),
    /// Continues to resend until it gets stopped manually
    KeepAlive,
}

impl<Ip: IpAddress> Drop for Handle<Ip> {
    fn drop(&mut self) {
        self.to_client.send(ServerEvent::Shutdown).ok();
    }
}

pub(crate) mod private {
    use super::*;

    pub trait Requestable<Ip: IpAddress> {
        fn into_event(self, id: usize, kind: RequestKind) -> ServerEvent<Ip>;
    }

    impl<Ip: IpAddress> Requestable<Ip> for InboundMap<Ip> {
        fn into_event(self, id: usize, kind: RequestKind) -> ServerEvent<Ip> {
            ServerEvent::InboundMap {
                map: self,
                kind,
                id,
            }
        }
    }

    impl<Ip: IpAddress> Requestable<Ip> for OutboundMap<Ip> {
        fn into_event(self, id: usize, kind: RequestKind) -> ServerEvent<Ip> {
            ServerEvent::OutboundMap {
                map: self,
                kind,
                id,
            }
        }
    }
}
