use super::event::ServerEvent;
use super::map::{InboundMap, Map, OutboundMap};
use crate::types::ParsingError;
use crate::IpAddress;
use std::sync::mpsc::{self, RecvError};
use std::{fmt, io};

/// Error generated by PCP operations
#[derive(Debug)]
pub enum Error {
    /// Error generated by an I/O operation related to the UDP sockets used for
    /// communication with the PCP server
    Socket(io::Error),

    /// Error generated by one of the channels used for the communication
    /// between the running threads
    Channel(RecvError),

    /// Warning generated when the server responds with a packet with an unknown
    /// format or some invalid values
    Parsing(ParsingError),
}

impl From<io::Error> for Error {
    fn from(err: io::Error) -> Self {
        Self::Socket(err)
    }
}

impl From<RecvError> for Error {
    fn from(err: RecvError) -> Self {
        Self::Channel(err)
    }
}

impl From<ParsingError> for Error {
    fn from(err: ParsingError) -> Self {
        Self::Parsing(err)
    }
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Socket(err) => write!(f, "Socket error: {:?}", err),
            Self::Channel(err) => write!(f, "Inner threads communication error: {:?}", err),
            Self::Parsing(err) => write!(f, "Response parsing error: {:?}", err),
        }
    }
}

/// An handle to a PCP client service
///
/// When a `Client` is started its `Handle` is returned and can be used to
///
/// # Examples
/// `request` mappings and to query its state.
///
/// ### Submitting a request
///
/// Request an inbound mapping to the port 120 TCP:
/// ```
/// // Start the PCP client service
/// let handle = Client::<Ipv4Addr>::start(client, server).unwrap();
///
/// // Allows for any host to connect on the TCP port number 120
/// // (see map module)
/// let map = InboundMap::new(6000, 120).protocol(ProtocolNumber::Tcp);
///
/// // Submit the request to the client, it will live one time
/// let map_handle = handle.request(map, RequestType::Once).unwrap();
/// ```
///
/// ### Querying the state
///
/// Check if the `Client` reported any errors:
///
/// ```
/// // Start the PCP client service
/// let handle = Client::<Ipv4Addr>::start(client, server).unwrap();
///
/// // Do stuff...
///
/// // Non blocking, use wait_err to block until a new error arrives
/// if let Some(err) = handle.poll_err() {
/// println!("The client reported an error: {}", err);
/// }
/// ```
pub struct Handle<Ip: IpAddress> {
    to_client: mpsc::Sender<ServerEvent<Ip>>,
    from_client: mpsc::Receiver<Error>,
}

impl<Ip: IpAddress> Handle<Ip> {
    pub(crate) fn new(
        to_client: mpsc::Sender<ServerEvent<Ip>>,
        from_client: mpsc::Receiver<Error>,
    ) -> Self {
        Handle {
            to_client,
            from_client,
        }
    }

    /// Waits for an error to arrive
    pub fn wait_err(&self) -> Error {
        self.from_client.recv().unwrap_or_else(Error::from)
    }

    /// Returns `Some(Error)` if an error has been received, `None` otherwise
    pub fn poll_err(&self) -> Option<Error> {
        self.from_client.try_recv().ok()
    }

    /// Signals the `Client` to end execution
    pub fn shutdown(self) {
        self.to_client.send(ServerEvent::Shutdown).ok();
    }
}

/// The number of times a request has to be submitted
#[derive(Debug, PartialEq)]
pub enum RequestType {
    /// Repeats for N times after the first submit (thus a value of 0 means only once)
    Repeat(usize),
    /// Continues to resend until it gets stopped manually
    KeepAlive,
}

// TODO: modify this trait to be implemented on the Requestable items instead that on the Handle

/// Used to specify that the type implementing this trait can request PCP mappings
pub trait Requester<M: Map> {
    /// Requests the mapping and returns its identifier
    fn request(&self, map: M, kind: RequestType) -> Result<usize, Error>;
}

impl<Ip: IpAddress> Requester<InboundMap<Ip>> for Handle<Ip> {
    fn request(&self, map: InboundMap<Ip>, kind: RequestType) -> Result<usize, Error> {
        let (id_tx, id_rx) = mpsc::channel();
        self.to_client
            .send(ServerEvent::InboundMap(map, kind, id_tx))
            .unwrap();
        id_rx.recv().unwrap().ok_or_else(|| self.wait_err())
    }
}

impl<Ip: IpAddress> Requester<OutboundMap<Ip>> for Handle<Ip> {
    fn request(&self, map: OutboundMap<Ip>, kind: RequestType) -> Result<usize, Error> {
        let (id_tx, id_rx) = mpsc::channel();
        self.to_client
            .send(ServerEvent::OutboundMap(map, kind, id_tx))
            .unwrap();
        id_rx.recv().unwrap().ok_or_else(|| self.wait_err())
    }
}

impl<Ip: IpAddress> Drop for Handle<Ip> {
    fn drop(&mut self) {
        self.to_client.send(ServerEvent::Shutdown).ok();
    }
}
